
## 各块RAM在总线中的位置

![](drafts/Pasted%20image%2020230618154108.png)
这个图可以方便识别总线所外挂的外设，共分为三个域：D1 Domain，D2 Domain和D3 Domain。

1、  ITCM和DTCM

这两个是直连CPU的。

2、  D1 Domain

D1域中的各个外设是挂在64位AXI总线组成6*7的矩阵上。

-   6个从接口端ASIB1到ASIB6

外接的主控是LTDC，DMA2D，MDMA，SDMMC1，AXIM和D2-to-D1 AHB 总线。

-   7个主接口端AMIB1到AMIB7

外接的从设备是AHB3总线，Flash A，Flash B，FMC总线，QSPI和AXI SRAM。另外AHB3也是由AXI总线分支出来的，然后再由AHB3分支出APB3总线。

3、  D2 Domain

D2域的各个外设是挂在32位AHB总线组成10*9的矩阵上。

-   10个从接口

外接的主控是D1-to-D2 AHB 总线，AHBP总线，DMA1，DMA2，Ethernet MAC，SDMMC2，USB HS1和USB HS2。

-   9个主接口

外接的从设备是SRAM1，SRMA2，SRAM3，AHB1，AHB2，APB1，APB2，D2-to-D1 AHB总线和D2-to-D3 AHB总线。

4、  D3 Domain

D3域的各个外设是挂在32位AHB总线组成3*2的矩阵上。

-  3个从接口

外接的主控D1-to-D3 AHB总线，D2-to-D3 AHB总线和BDMA。

-  2个主接口

外接的从设备是AHB4，SRAM4和Bckp SRAM。另外AHB4也是这个总线矩阵分支出来的，然后再由AHB4分支出APB4总线

## 各块RAM特性

注意他们支持的最大速度和容量大小。

### TCM
Tightly-Coupled Memory 紧密耦合内存 。是一种高速缓存，被直接集成在CPU芯片中。
将需要实时性的程序和变量分别放在ITCM和DTCM里面执行
DS有两种TCM
ITCM用于运行指令，也就是程序代码，DTCM用于数据存取，特点是跟内核速度一样，而片上RAM的速度基本都达不到这个速度，所以有降频处理。
DTCM是H7里面性能最高的RAM，主频400MHz，跟内核速度一样。优先使用DTCM
DTCM地址：0x2000 0000，大小128KB。
ITCM地址：0x0000 0000，大小64KB。
ITCM：Instruction TCM，cortex内核中指令传输总线
DTCM：Data TCM，cortex内核中指令传输总线
是cpu内核同flash及sram之间传输指令和数据的通道，指令的取指和执行及数据的读写在性能及管理上存在差异性，因而需要予以区分。

ITCM：推荐存放对执行效率较高的代码，有效地提高运行速度
DTCM：推荐存放需要频繁存取的数据，节省存取时间
两个TCM支持映射，但一般会映射到固定地址
这两块内存空间都是有特殊用途的，所以不建议直接访问。相比于ITCM来说，DTCM更加重要。因为在这块内存中，存在着一个非常重要的对象——栈。局部变量和函数调用的参数，就是靠栈进行传递的。由于DMA无法访问TCM，所以也就无法访问栈。又由于局部变量是被开辟到栈中，所以DMA也无法对局部变量进行传递。

将代码放入ITCM中的方法
1. 使用gcc特有的“属性标签”，将指定代码赋予“ITCM”属性，该代码会被载入ITCM中执行
2. 直接将.c源文件改成.itcm.c，此时源文件会被直接编译成在ITCM中运行的目标文件

DS：内存支持列表中，内存详细参数里，SS指的是单面内存，DS指的是双面内存。内存一共有两面，根据内存总容量和内存芯片的存储容量，内存厂家会生产双面内存和单面内存，也就是内存的两面都有存储芯片，或者只有一面有存储芯片。单双面内存在兼容性上有一定区别，所以会单独列出来。






[【STM32H7教程】第25章 STM32H7的TCM，SRAM等五块内存基础知识 - 硬汉嵌入式 - 博客园 (cnblogs.com)](https://www.cnblogs.com/armfly/p/11014230.html)


Cache
众所周知CPU的速度非常快。当CPU访问外设的时候，有些外设速度比较慢，响应CPU比较迟钝。此时CPU要么等外设响应，要么继续干它的活等外设的中断信号。但是有些外设是没有中断的。此时CPU就必须等了。最典型的例子就是内存。当CPU访问内存的时候，并非像你想象的那样，CPU立刻就能访问到它想访问的内存空间，而是有一个“WaitState”的过程。想想看吧，每访问一次内存都要等上几个机器周期，这可不是个好事尤其是，这个“几”可不是简单的一位数，有些时候甚至能达到3位数。
那么这个问题又该怎么解决呢？那就是Cache了。
Cache是集成在CPU内部的极高速的缓存。注意关键词“极高速”。一般来说，它的访问速度几乎可以媲美CPU。这就意味着，CPU在访问Cache的时候几乎不会浪费多少时间。不过，速度的提升是用容量作为代价的。Cache的容量很小。

那么，我们把常用的数据放到Cache中，CPU在访问的时候直接访问Cache就行了，不用耗费时间去访问内存了。
事实上CPU就是这么做的。在读内存的时候，CPU首先读Cache，看看有没有它想要的数据的“副本”，有的话那就太好了，直接拿过去用。没有的话就只好费点功夫去读内存了。而在写内存的时候，CPU直接写到Cache中，而非直接写到内存中。Cache写满了之后，此时才将Cache中的数据更新到内存，同时清空Cache。就像寄信一样，所有的信件会首先攒到邮局，到达一定数量之后才会送出去。
不过这又出现一个问题：假如Cache中有某个内存数据的“副本”，那么CPU在读该内存的时候就会直接使用该副本而不用去读内存。那万一内存中的数据被改写，此时CPU再读该内存，读出来的岂不是那个旧的副本而不是最新的内存数据？同样，假如我想DMA一些数据，谁能保证此时内存中的数据就是最新的数据？很可惜，Cache是完全的黑箱。你不知道它的地址。你也无法直接访问它，但一般系统会提供函数进行cache回写和clear操作，比如

//将整个Data Cache更新到内存

void DC_FlushAll()

// 清空整个Data Cache
void DC_InvalidateAll()
那么，什么时候使用这些函数呢？
在DMA之前，我需要保证数据源内存中的数据是最新的。所以此时需要Flush，从而使DC中的副本能够更新到内存中。
在DMA之后，我需要保证DC中的副本和内存中的数据是相同的。但是NDSLIB没有更新DC的函数，所以没办法，我们只能把DC中的副本杀掉。此时如果CPU访问内存，由于DC中没有副本，所以就只能直接从内存访问并将访问到的值作为DC中副本了。所以此时需要Invalidate

DMA

DMA=Direct Memory Access。这是一种通过硬件实现的数据传输机制。简单的说，就是不在CPU的参与下完成数据的传输。
DMA是一种硬件设备。这种设备的工作原理是这样的：
——首先CPU告诉DMA设备，要有一堆数据需要传输，为了效率而请它出马。（DMA请求）
——DMA收到CPU的消息，开始准备。此时CPU把数据源地址、数据目标地址、传输数据量、传输模式等等参数告诉它。（DMA初始化）
——DMA初始化完，向CPU发送消息“借你的总线用一用，我要开始传输数据了！”（总线出借，DMA启动）
——CPU收到消息后，暂时切断自己与总线的联系。DMA开始传输数据。（DMA数据）
——DMA传输完数据之后，向CPU发送消息“搞定了！总线还给你。”（总线归还）
——CPU说：“干得好！老将出马一个顶俩！辛苦了，你先歇着吧。”DMA设备停止。CPU该干啥干啥。
由于是硬件实现的，所以DMA的速度非常快。快到什么程度呢？在DS上，尤其是数据量非常大的时候，相比于CPU当中介，效率能够提高一百万倍以上。
由于DMA的速度是如此之快，所以大量的数据传输，一般都要求使用DMA。


ROM
只读存储器，只能从里面读出数据而不能任意写入数据。ROM与RAM相比,具有读写速度慢的缺点。但由于其具有掉电后数据可保持不变的优点，因此常用于存放一次性写入的程序和数据

RAM
随机存取存储器，存储的内容可通过指令随机读写访问。RAM中存储的数据在掉电时会丢失，因而只能在开机运行时存储数据。其中RAM又可以分为两种，一种是Dynamic RAM(DRAM动态随机存储器),另一种是Static RAM(SRAM,静态随机存储器)。

Flash Memory
是ROM的发展，不仅具有ROM掉电不丢失数据的特点，又可以在需要的时候对数据进行更改，不过价格比ROM要高。故可将Flash理解成ROM的一种

在Keil编译器中，查看.map文件
Code：代码占用大小
RO-data：只读常量大小，read only，如const
RW-data：已初始化非0的变量，read/write，如已初始化static、全局变量
ZI-data：未初始化或初始化为0的变量，zero initialize，如未初始化static、全局变量

程序镜像占用大小，即烧录bin文件大小，静态
ROM（flash） = Code + RO-data + RW-data
程序运行时大小，动态
RAM = RW-data + ZI-data + Stack + Heap
为什么ROM中还要存RW，因为掉电后RAM中所有数据都丢失了，每次上电RAM中的数据是被重新赋值的，每次这些固定的值就是存储在ROM中的
为什么不包含ZI段呢，是因为ZI数据都是0，没必要包含，只要程序运行之前将ZI数据所在的区域一律清零即可。包含进去反而浪费存储空间。

MCU执行过程
1. 先将RW从ROM中搬到RAM中，因为RW是变量，变量不能存在ROM中
2. 将ZI所在的RAM区域全部清零，ZI区域并不在Image中，所以需要程序根据编译器给出的ZI地址及大小来将相应得RAM区域清零。ZI中也是变量，同理：变量不能存在ROM中。
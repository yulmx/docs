
## 概念

镜像大小：指可执行文件大小，如二进制bin文件
内存大小：指运行时占用内存大小

## 计算方式

### 镜像大小

> 所有运行时将被加载的段size之和，即为镜像大小

被加载的本质：
在程序初始化阶段，是否需要读。
若只需要写内存，不需要读内存，则该段均可配置成NOLOAD
eg：
1. heap/stack，只需有空间进行内存分配，初始化时不会读内容
2. bss，全存储0，只需初始化时分配空间并初始化为0既可
3. text/data，存储初始化的代码指令和数据，需要从内存中读取数据并加载

1. 会被加载的段
```
.text: 代码段
.data: 数据段（已初始化为非0的全局变量和静态变量）
.rodata: 只读数据段（const全局变量）
.startup: 程序起始地址段
.xxx: 其他（自定义）
```
2. 不会被加载的段

```
.stack: 栈
.bss: （未初始化的全局变量和静态变量或初始化为0）
.rodata: 只读数据段（const全局变量）
.heap: 堆
.xxx: 其他（调试debug等）
```

### 查看段加载情况
1. 查看链接脚本lds文件，看SECTION中的段是否有NOLOAD标识

### 查看段size大小

```
objdump -h <可执行文件elf>
```
每个段信息，可在链接脚本中找到对应的存储区（区域REGION）

### 计算公式

镜像大小=startup+text+data+rodata+other

## 优化镜像大小

1. 减少代码量，去除无用代码
2. 功能业务裁剪，如不同版本中的需求不一样，在商用版本中不需要，可以用宏控制启用
3. 全局变量/静态变量避免无效的非零初始化（非零初始化，占镜像大小；零初始化，不占镜像大小）
4. 优化字符串常量，（字符串常量存放在.text段中，一般在日志打印中大量使用）
5. 优化宏定义和inline函数（会在代码中展开） #待验证